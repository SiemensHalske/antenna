
/home/bortex/.cache/arduino/sketches/325D6315B7BBF8BB6F691C270A82D49A/antenna.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	1e c0       	rjmp	.+60     	; 0x3e <__ctors_end>
   2:	37 c0       	rjmp	.+110    	; 0x72 <__bad_interrupt>
   4:	36 c0       	rjmp	.+108    	; 0x72 <__bad_interrupt>
   6:	35 c0       	rjmp	.+106    	; 0x72 <__bad_interrupt>
   8:	34 c0       	rjmp	.+104    	; 0x72 <__bad_interrupt>
   a:	c0 c0       	rjmp	.+384    	; 0x18c <__vector_5>
   c:	32 c0       	rjmp	.+100    	; 0x72 <__bad_interrupt>
   e:	31 c0       	rjmp	.+98     	; 0x72 <__bad_interrupt>
  10:	30 c0       	rjmp	.+96     	; 0x72 <__bad_interrupt>
  12:	2f c0       	rjmp	.+94     	; 0x72 <__bad_interrupt>
  14:	2e c0       	rjmp	.+92     	; 0x72 <__bad_interrupt>
  16:	2d c0       	rjmp	.+90     	; 0x72 <__bad_interrupt>
  18:	2c c0       	rjmp	.+88     	; 0x72 <__bad_interrupt>
  1a:	ac c1       	rjmp	.+856    	; 0x374 <__vector_13>
  1c:	01 c1       	rjmp	.+514    	; 0x220 <__vector_14>

0000001e <__trampolines_end>:
__trampolines_start():
  1e:	00 00       	nop
  20:	00 00       	nop
  22:	37 00       	.word	0x0037	; ????

00000024 <port_to_output_PGM>:
  24:	00 00 00 00 38 00                                   ....8.

0000002a <digital_pin_to_port_PGM>:
  2a:	02 02 02 02 02 02                                   ......

00000030 <digital_pin_to_bit_mask_PGM>:
  30:	01 02 04 08 10 20                                   ..... 

00000036 <digital_pin_to_timer_PGM>:
  36:	01 03 00 00 04 00                                   ......

0000003c <__ctors_start>:
__ctors_start():
  3c:	50 02       	muls	r21, r16

0000003e <__ctors_end>:
__dtors_end():
  3e:	11 24       	eor	r1, r1
  40:	1f be       	out	0x3f, r1	; 63
  42:	cf e5       	ldi	r28, 0x5F	; 95
  44:	d2 e0       	ldi	r29, 0x02	; 2
  46:	de bf       	out	0x3e, r29	; 62
  48:	cd bf       	out	0x3d, r28	; 61

0000004a <__do_clear_bss>:
__do_clear_bss():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  4a:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  4c:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  4e:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  50:	01 c0       	rjmp	.+2      	; 0x54 <.do_clear_bss_start>

00000052 <.do_clear_bss_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  52:	1d 92       	st	X+, r1

00000054 <.do_clear_bss_start>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  54:	a6 38       	cpi	r26, 0x86	; 134
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  56:	b2 07       	cpc	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  58:	e1 f7       	brne	.-8      	; 0x52 <.do_clear_bss_loop>

0000005a <__do_global_ctors>:
__do_global_ctors():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  5a:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  5c:	cf e1       	ldi	r28, 0x1F	; 31
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  5e:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  60:	03 c0       	rjmp	.+6      	; 0x68 <__do_global_ctors+0xe>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  62:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  64:	fe 01       	movw	r30, r28
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  66:	22 d2       	rcall	.+1092   	; 0x4ac <__tablejump2__>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  68:	ce 31       	cpi	r28, 0x1E	; 30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  6a:	d1 07       	cpc	r29, r17
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  6c:	d1 f7       	brne	.-12     	; 0x62 <__do_global_ctors+0x8>
  6e:	9f d1       	rcall	.+830    	; 0x3ae <main>
  70:	23 c2       	rjmp	.+1094   	; 0x4b8 <_exit>

00000072 <__bad_interrupt>:
__vector_1():
  72:	c6 cf       	rjmp	.-116    	; 0x0 <__vectors>

00000074 <digitalWrite>:
digitalWrite():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:138
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  74:	87 ff       	sbrs	r24, 7
  76:	09 c0       	rjmp	.+18     	; 0x8a <digitalWrite+0x16>
  78:	8f 77       	andi	r24, 0x7F	; 127
  7a:	71 f1       	breq	.+92     	; 0xd8 <digitalWrite+0x64>
  7c:	81 30       	cpi	r24, 0x01	; 1
  7e:	71 f1       	breq	.+92     	; 0xdc <digitalWrite+0x68>
  80:	82 30       	cpi	r24, 0x02	; 2
  82:	71 f1       	breq	.+92     	; 0xe0 <digitalWrite+0x6c>
  84:	83 30       	cpi	r24, 0x03	; 3
  86:	71 f1       	breq	.+92     	; 0xe4 <digitalWrite+0x70>
  88:	8f ef       	ldi	r24, 0xFF	; 255
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:139
  uint8_t timer = digitalPinToTimer(pin);
  8a:	90 e0       	ldi	r25, 0x00	; 0
  8c:	fc 01       	movw	r30, r24
  8e:	ea 5c       	subi	r30, 0xCA	; 202
  90:	ff 4f       	sbci	r31, 0xFF	; 255
  92:	34 91       	lpm	r19, Z
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:140
  uint8_t bit = digitalPinToBitMask(pin);
  94:	fc 01       	movw	r30, r24
  96:	e0 5d       	subi	r30, 0xD0	; 208
  98:	ff 4f       	sbci	r31, 0xFF	; 255
  9a:	24 91       	lpm	r18, Z
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:141
  uint8_t port = digitalPinToPort(pin);
  9c:	fc 01       	movw	r30, r24
  9e:	e6 5d       	subi	r30, 0xD6	; 214
  a0:	ff 4f       	sbci	r31, 0xFF	; 255
  a2:	e4 91       	lpm	r30, Z
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:144
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
  a4:	ee 23       	and	r30, r30
  a6:	b9 f0       	breq	.+46     	; 0xd6 <digitalWrite+0x62>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:148

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
  a8:	33 23       	and	r19, r19
  aa:	29 f0       	breq	.+10     	; 0xb6 <digitalWrite+0x42>
turnOffPWM():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
    if( timer == TIMER0A){
  ac:	31 30       	cpi	r19, 0x01	; 1
  ae:	e1 f4       	brne	.+56     	; 0xe8 <digitalWrite+0x74>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:68
      cbi(TCCR0A, COM0A1);
  b0:	8a b5       	in	r24, 0x2a	; 42
  b2:	8f 77       	andi	r24, 0x7F	; 127
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:74
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
      cbi(TCCR0A, COM0B1);
  b4:	8a bd       	out	0x2a, r24	; 42
digitalWrite():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:150

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
  b6:	f0 e0       	ldi	r31, 0x00	; 0
  b8:	ee 0f       	add	r30, r30
  ba:	ff 1f       	adc	r31, r31
  bc:	ec 5d       	subi	r30, 0xDC	; 220
  be:	ff 4f       	sbci	r31, 0xFF	; 255
  c0:	a5 91       	lpm	r26, Z+
  c2:	b4 91       	lpm	r27, Z
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:153

  if (val == LOW) {
    uint8_t oldSREG = SREG;
  c4:	8f b7       	in	r24, 0x3f	; 63
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
  c6:	61 11       	cpse	r22, r1
  c8:	20 c0       	rjmp	.+64     	; 0x10a <digitalWrite+0x96>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:154
    uint8_t oldSREG = SREG;
    cli();
  ca:	f8 94       	cli
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:155
    *out &= ~bit;
  cc:	ec 91       	ld	r30, X
  ce:	20 95       	com	r18
  d0:	2e 23       	and	r18, r30
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:160
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
  d2:	2c 93       	st	X, r18
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:161
    SREG = oldSREG;
  d4:	8f bf       	out	0x3f, r24	; 63
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:163
  }
}
  d6:	08 95       	ret
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:138
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  d8:	85 e0       	ldi	r24, 0x05	; 5
  da:	d7 cf       	rjmp	.-82     	; 0x8a <digitalWrite+0x16>
  dc:	82 e0       	ldi	r24, 0x02	; 2
  de:	d5 cf       	rjmp	.-86     	; 0x8a <digitalWrite+0x16>
  e0:	84 e0       	ldi	r24, 0x04	; 4
  e2:	d3 cf       	rjmp	.-90     	; 0x8a <digitalWrite+0x16>
  e4:	83 e0       	ldi	r24, 0x03	; 3
  e6:	d1 cf       	rjmp	.-94     	; 0x8a <digitalWrite+0x16>
turnOffPWM():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:73
      cbi(TCCR0A, COM0A1);
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
  e8:	32 30       	cpi	r19, 0x02	; 2
  ea:	19 f4       	brne	.+6      	; 0xf2 <digitalWrite+0x7e>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:74
      cbi(TCCR0A, COM0B1);
  ec:	8a b5       	in	r24, 0x2a	; 42
  ee:	8f 7d       	andi	r24, 0xDF	; 223
  f0:	e1 cf       	rjmp	.-62     	; 0xb4 <digitalWrite+0x40>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:106
      //cbi(TCCR1C,COM1D0);
    } else
  #else
    // Timer1 for non-x61/x7
    #if defined(TCCR1) && defined(COM1A1) // x5
      if(timer == TIMER1A){
  f2:	33 30       	cpi	r19, 0x03	; 3
  f4:	21 f4       	brne	.+8      	; 0xfe <digitalWrite+0x8a>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:107
        TCCR1 &= ~(1<<COM1A1);
  f6:	80 b7       	in	r24, 0x30	; 48
  f8:	8f 7d       	andi	r24, 0xDF	; 223
  fa:	80 bf       	out	0x30, r24	; 48
  fc:	dc cf       	rjmp	.-72     	; 0xb6 <digitalWrite+0x42>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:112
        //cbi(TCCR1, COM1A0);
      } else
    #endif
    #if defined(TCCR1) && defined(COM1B1) // x5
      if( timer == TIMER1B){
  fe:	34 30       	cpi	r19, 0x04	; 4
 100:	d1 f6       	brne	.-76     	; 0xb6 <digitalWrite+0x42>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:113
        GTCCR &= ~(1<<COM1B1);
 102:	8c b5       	in	r24, 0x2c	; 44
 104:	8f 7d       	andi	r24, 0xDF	; 223
 106:	8c bd       	out	0x2c, r24	; 44
 108:	d6 cf       	rjmp	.-84     	; 0xb6 <digitalWrite+0x42>
digitalWrite():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:159
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 10a:	f8 94       	cli
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:160
    *out |= bit;
 10c:	ec 91       	ld	r30, X
 10e:	2e 2b       	or	r18, r30
 110:	e0 cf       	rjmp	.-64     	; 0xd2 <digitalWrite+0x5e>

00000112 <receiveI2C(unsigned char)>:
_Z10receiveI2Ch():
/home/bortex/arduino/antenna/antenna.ino:50
// === GLOBAL INSTANCE ===
RelaisController relais(RELAY_PIN);

// === I2C RECEIVE HANDLER ===
void receiveI2C(uint8_t howMany)
{
 112:	cf 93       	push	r28
usiTwiAmountDataInReceiveBuffer():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:459



uint8_t usiTwiAmountDataInReceiveBuffer(void)
{
    return rxCount;
 114:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <rxCount>
_Z10receiveI2Ch():
/home/bortex/arduino/antenna/antenna.ino:52
  // TinyWireS.available() / receive() behave like Wire.read()
  if (TinyWireS.available() < 1)
 118:	88 23       	and	r24, r24
 11a:	09 f1       	breq	.+66     	; 0x15e <receiveI2C(unsigned char)+0x4c>
usiTwiReceiveByte():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:443
)
{
  uint8_t rtn_byte;

  // wait for Rx data
  while ( !rxCount );
 11c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <rxCount>
 120:	88 23       	and	r24, r24
 122:	e1 f3       	breq	.-8      	; 0x11c <receiveI2C(unsigned char)+0xa>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:445

  rtn_byte = rxBuf [ rxTail ];
 124:	e0 91 76 00 	lds	r30, 0x0076	; 0x800076 <rxTail>
 128:	f0 e0       	ldi	r31, 0x00	; 0
 12a:	e0 5a       	subi	r30, 0xA0	; 160
 12c:	ff 4f       	sbci	r31, 0xFF	; 255
 12e:	c0 81       	ld	r28, Z
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:447
  // calculate buffer index
  rxTail = ( rxTail + 1 ) & TWI_RX_BUFFER_MASK;
 130:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <rxTail>
 134:	8f 5f       	subi	r24, 0xFF	; 255
 136:	8f 70       	andi	r24, 0x0F	; 15
 138:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <rxTail>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:448
  rxCount--;
 13c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <rxCount>
 140:	81 50       	subi	r24, 0x01	; 1
 142:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <rxCount>
_Z10receiveI2Ch():
/home/bortex/arduino/antenna/antenna.ino:56
    return;
  uint8_t cmd = TinyWireS.receive();

  switch (cmd)
 146:	c2 30       	cpi	r28, 0x02	; 2
 148:	61 f0       	breq	.+24     	; 0x162 <receiveI2C(unsigned char)+0x50>
 14a:	c3 30       	cpi	r28, 0x03	; 3
 14c:	89 f0       	breq	.+34     	; 0x170 <receiveI2C(unsigned char)+0x5e>
 14e:	c1 30       	cpi	r28, 0x01	; 1
 150:	31 f4       	brne	.+12     	; 0x15e <receiveI2C(unsigned char)+0x4c>
on():
/home/bortex/arduino/antenna/antenna.ino:27
    pinMode(pin, OUTPUT);
    off();
  }
  void on()
  {
    digitalWrite(pin, HIGH);
 152:	61 e0       	ldi	r22, 0x01	; 1
 154:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <relais>
 158:	8d df       	rcall	.-230    	; 0x74 <digitalWrite>
/home/bortex/arduino/antenna/antenna.ino:28
    state = true;
 15a:	c0 93 79 00 	sts	0x0079, r28	; 0x800079 <relais+0x1>
_Z10receiveI2Ch():
/home/bortex/arduino/antenna/antenna.ino:70
    relais.toggle();
    break;
  default: /* ignore */
    break;
  }
}
 15e:	cf 91       	pop	r28
 160:	08 95       	ret
off():
/home/bortex/arduino/antenna/antenna.ino:32
    digitalWrite(pin, HIGH);
    state = true;
  }
  void off()
  {
    digitalWrite(pin, LOW);
 162:	60 e0       	ldi	r22, 0x00	; 0
 164:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <relais>
 168:	85 df       	rcall	.-246    	; 0x74 <digitalWrite>
/home/bortex/arduino/antenna/antenna.ino:33
    state = false;
 16a:	10 92 79 00 	sts	0x0079, r1	; 0x800079 <relais+0x1>
 16e:	f7 cf       	rjmp	.-18     	; 0x15e <receiveI2C(unsigned char)+0x4c>
 170:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <relais>
toggle():
/home/bortex/arduino/antenna/antenna.ino:37
  }
  void toggle()
  {
    state ? off() : on();
 174:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <relais+0x1>
 178:	99 23       	and	r25, r25
 17a:	11 f0       	breq	.+4      	; 0x180 <receiveI2C(unsigned char)+0x6e>
off():
/home/bortex/arduino/antenna/antenna.ino:32
    digitalWrite(pin, HIGH);
    state = true;
  }
  void off()
  {
    digitalWrite(pin, LOW);
 17c:	60 e0       	ldi	r22, 0x00	; 0
 17e:	f4 cf       	rjmp	.-24     	; 0x168 <receiveI2C(unsigned char)+0x56>
on():
/home/bortex/arduino/antenna/antenna.ino:27
    pinMode(pin, OUTPUT);
    off();
  }
  void on()
  {
    digitalWrite(pin, HIGH);
 180:	61 e0       	ldi	r22, 0x01	; 1
 182:	78 df       	rcall	.-272    	; 0x74 <digitalWrite>
/home/bortex/arduino/antenna/antenna.ino:28
    state = true;
 184:	81 e0       	ldi	r24, 0x01	; 1
 186:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <relais+0x1>
 18a:	e9 cf       	rjmp	.-46     	; 0x15e <receiveI2C(unsigned char)+0x4c>

0000018c <__vector_5>:
__vector_5():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:308
      #error "cannot find Millis() timer overflow vector"
    #endif
  #else
    #error "Millis() timer not defined!"
  #endif
  {
 18c:	1f 92       	push	r1
 18e:	0f 92       	push	r0
 190:	0f b6       	in	r0, 0x3f	; 63
 192:	0f 92       	push	r0
 194:	11 24       	eor	r1, r1
 196:	2f 93       	push	r18
 198:	3f 93       	push	r19
 19a:	8f 93       	push	r24
 19c:	9f 93       	push	r25
 19e:	af 93       	push	r26
 1a0:	bf 93       	push	r27
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:311
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = millis_timer_millis;
 1a2:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <millis_timer_millis>
 1a6:	90 91 83 00 	lds	r25, 0x0083	; 0x800083 <millis_timer_millis+0x1>
 1aa:	a0 91 84 00 	lds	r26, 0x0084	; 0x800084 <millis_timer_millis+0x2>
 1ae:	b0 91 85 00 	lds	r27, 0x0085	; 0x800085 <millis_timer_millis+0x3>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:312
    unsigned char f = millis_timer_fract;
 1b2:	30 91 81 00 	lds	r19, 0x0081	; 0x800081 <millis_timer_fract>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:319
    static unsigned char correct_exact = 0;     // rollover intended
    if (++correct_exact < CORRECT_EXACT_MANY) {
      ++f;
    }
#endif
    f += FRACT_INC;
 1b6:	26 e0       	ldi	r18, 0x06	; 6
 1b8:	23 0f       	add	r18, r19
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:321

    if (f >= FRACT_MAX)
 1ba:	2d 37       	cpi	r18, 0x7D	; 125
 1bc:	68 f1       	brcs	.+90     	; 0x218 <__vector_5+0x8c>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:323
    {
      f -= FRACT_MAX;
 1be:	29 e8       	ldi	r18, 0x89	; 137
 1c0:	23 0f       	add	r18, r19
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:324
      m += MILLIS_INC + 1;
 1c2:	03 96       	adiw	r24, 0x03	; 3
 1c4:	a1 1d       	adc	r26, r1
 1c6:	b1 1d       	adc	r27, r1
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:331
    else
    {
      m += MILLIS_INC;
    }

    millis_timer_fract = f;
 1c8:	20 93 81 00 	sts	0x0081, r18	; 0x800081 <millis_timer_fract>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:332
    millis_timer_millis = m;
 1cc:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <millis_timer_millis>
 1d0:	90 93 83 00 	sts	0x0083, r25	; 0x800083 <millis_timer_millis+0x1>
 1d4:	a0 93 84 00 	sts	0x0084, r26	; 0x800084 <millis_timer_millis+0x2>
 1d8:	b0 93 85 00 	sts	0x0085, r27	; 0x800085 <millis_timer_millis+0x3>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:334
#ifndef CORRECT_EXACT_MICROS
    millis_timer_overflow_count++;
 1dc:	80 91 7d 00 	lds	r24, 0x007D	; 0x80007d <millis_timer_overflow_count>
 1e0:	90 91 7e 00 	lds	r25, 0x007E	; 0x80007e <millis_timer_overflow_count+0x1>
 1e4:	a0 91 7f 00 	lds	r26, 0x007F	; 0x80007f <millis_timer_overflow_count+0x2>
 1e8:	b0 91 80 00 	lds	r27, 0x0080	; 0x800080 <millis_timer_overflow_count+0x3>
 1ec:	01 96       	adiw	r24, 0x01	; 1
 1ee:	a1 1d       	adc	r26, r1
 1f0:	b1 1d       	adc	r27, r1
 1f2:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <millis_timer_overflow_count>
 1f6:	90 93 7e 00 	sts	0x007E, r25	; 0x80007e <millis_timer_overflow_count+0x1>
 1fa:	a0 93 7f 00 	sts	0x007F, r26	; 0x80007f <millis_timer_overflow_count+0x2>
 1fe:	b0 93 80 00 	sts	0x0080, r27	; 0x800080 <millis_timer_overflow_count+0x3>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:336
#endif
  }
 202:	bf 91       	pop	r27
 204:	af 91       	pop	r26
 206:	9f 91       	pop	r25
 208:	8f 91       	pop	r24
 20a:	3f 91       	pop	r19
 20c:	2f 91       	pop	r18
 20e:	0f 90       	pop	r0
 210:	0f be       	out	0x3f, r0	; 63
 212:	0f 90       	pop	r0
 214:	1f 90       	pop	r1
 216:	18 95       	reti
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:328
      f -= FRACT_MAX;
      m += MILLIS_INC + 1;
    }
    else
    {
      m += MILLIS_INC;
 218:	02 96       	adiw	r24, 0x02	; 2
 21a:	a1 1d       	adc	r26, r1
 21c:	b1 1d       	adc	r27, r1
 21e:	d4 cf       	rjmp	.-88     	; 0x1c8 <__vector_5+0x3c>

00000220 <__vector_14>:
__vector_14():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:564
Only disabled when waiting for a new Start Condition.

********************************************************************************/

ISR( USI_OVERFLOW_VECTOR )
{
 220:	1f 92       	push	r1
 222:	0f 92       	push	r0
 224:	0f b6       	in	r0, 0x3f	; 63
 226:	0f 92       	push	r0
 228:	11 24       	eor	r1, r1
 22a:	2f 93       	push	r18
 22c:	3f 93       	push	r19
 22e:	4f 93       	push	r20
 230:	5f 93       	push	r21
 232:	6f 93       	push	r22
 234:	7f 93       	push	r23
 236:	8f 93       	push	r24
 238:	9f 93       	push	r25
 23a:	af 93       	push	r26
 23c:	bf 93       	push	r27
 23e:	ef 93       	push	r30
 240:	ff 93       	push	r31
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:566

  switch ( overflowState )
 242:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <overflowState>
 246:	90 91 71 00 	lds	r25, 0x0071	; 0x800071 <overflowState+0x1>
 24a:	82 30       	cpi	r24, 0x02	; 2
 24c:	91 05       	cpc	r25, r1
 24e:	09 f4       	brne	.+2      	; 0x252 <__vector_14+0x32>
 250:	7f c0       	rjmp	.+254    	; 0x350 <__stack+0xf1>
 252:	b0 f4       	brcc	.+44     	; 0x280 <__stack+0x21>
 254:	00 97       	sbiw	r24, 0x00	; 0
 256:	a1 f1       	breq	.+104    	; 0x2c0 <__stack+0x61>
 258:	01 97       	sbiw	r24, 0x01	; 1
 25a:	09 f4       	brne	.+2      	; 0x25e <__vector_14+0x3e>
 25c:	58 c0       	rjmp	.+176    	; 0x30e <__stack+0xaf>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:659
      SET_USI_TO_SEND_ACK( );
      break;

  } // end switch

} // end ISR( USI_OVERFLOW_VECTOR )
 25e:	ff 91       	pop	r31
 260:	ef 91       	pop	r30
 262:	bf 91       	pop	r27
 264:	af 91       	pop	r26
 266:	9f 91       	pop	r25
 268:	8f 91       	pop	r24
 26a:	7f 91       	pop	r23
 26c:	6f 91       	pop	r22
 26e:	5f 91       	pop	r21
 270:	4f 91       	pop	r20
 272:	3f 91       	pop	r19
 274:	2f 91       	pop	r18
 276:	0f 90       	pop	r0
 278:	0f be       	out	0x3f, r0	; 63
 27a:	0f 90       	pop	r0
 27c:	1f 90       	pop	r1
 27e:	18 95       	reti
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:566
********************************************************************************/

ISR( USI_OVERFLOW_VECTOR )
{

  switch ( overflowState )
 280:	84 30       	cpi	r24, 0x04	; 4
 282:	91 05       	cpc	r25, r1
 284:	09 f4       	brne	.+2      	; 0x288 <__stack+0x29>
 286:	6e c0       	rjmp	.+220    	; 0x364 <__stack+0x105>
 288:	e0 f1       	brcs	.+120    	; 0x302 <__stack+0xa3>
 28a:	05 97       	sbiw	r24, 0x05	; 5
 28c:	41 f7       	brne	.-48     	; 0x25e <__vector_14+0x3e>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:643
    // copy data from USIDR and send ACK
    // next USI_SLAVE_REQUEST_DATA
    case USI_SLAVE_GET_DATA_AND_SEND_ACK:
      // put data into buffer
      // check buffer size
      if ( rxCount < TWI_RX_BUFFER_SIZE )
 28e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <rxCount>
 292:	80 31       	cpi	r24, 0x10	; 16
 294:	90 f4       	brcc	.+36     	; 0x2ba <__stack+0x5b>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:645
      {
        rxBuf[ rxHead ] = USIDR;
 296:	e0 91 75 00 	lds	r30, 0x0075	; 0x800075 <rxHead>
 29a:	8f b1       	in	r24, 0x0f	; 15
 29c:	f0 e0       	ldi	r31, 0x00	; 0
 29e:	e0 5a       	subi	r30, 0xA0	; 160
 2a0:	ff 4f       	sbci	r31, 0xFF	; 255
 2a2:	80 83       	st	Z, r24
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:646
        rxHead = ( rxHead + 1 ) & TWI_RX_BUFFER_MASK;
 2a4:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <rxHead>
 2a8:	8f 5f       	subi	r24, 0xFF	; 255
 2aa:	8f 70       	andi	r24, 0x0F	; 15
 2ac:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <rxHead>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:647
        rxCount++;
 2b0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <rxCount>
 2b4:	8f 5f       	subi	r24, 0xFF	; 255
 2b6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <rxCount>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:653
      } else {
        // overrun
        // drop data
      }
      // next USI_SLAVE_REQUEST_DATA
      overflowState = USI_SLAVE_REQUEST_DATA;
 2ba:	84 e0       	ldi	r24, 0x04	; 4
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	1a c0       	rjmp	.+52     	; 0x2f4 <__stack+0x95>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:572
  {

    // Address mode: check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK,
    // else reset USI
    case USI_SLAVE_CHECK_ADDRESS:
      if ( ( USIDR == 0 ) || ( ( USIDR >> 1 ) == slaveAddress) )
 2c0:	8f b1       	in	r24, 0x0f	; 15
 2c2:	88 23       	and	r24, r24
 2c4:	31 f0       	breq	.+12     	; 0x2d2 <__stack+0x73>
 2c6:	8f b1       	in	r24, 0x0f	; 15
 2c8:	86 95       	lsr	r24
 2ca:	90 91 77 00 	lds	r25, 0x0077	; 0x800077 <slaveAddress>
 2ce:	89 13       	cpse	r24, r25
 2d0:	1b c0       	rjmp	.+54     	; 0x308 <__stack+0xa9>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:574
      {
        if ( USIDR & 0x01 )
 2d2:	78 9b       	sbis	0x0f, 0	; 15
 2d4:	f2 cf       	rjmp	.-28     	; 0x2ba <__stack+0x5b>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:576
        {
          USI_REQUEST_CALLBACK();
 2d6:	e0 91 7b 00 	lds	r30, 0x007B	; 0x80007b <usi_onReceiverPtr>
 2da:	f0 91 7c 00 	lds	r31, 0x007C	; 0x80007c <usi_onReceiverPtr+0x1>
 2de:	30 97       	sbiw	r30, 0x00	; 0
 2e0:	39 f0       	breq	.+14     	; 0x2f0 <__stack+0x91>
usiTwiAmountDataInReceiveBuffer():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:459



uint8_t usiTwiAmountDataInReceiveBuffer(void)
{
    return rxCount;
 2e2:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <rxCount>
__vector_14():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:576
    case USI_SLAVE_CHECK_ADDRESS:
      if ( ( USIDR == 0 ) || ( ( USIDR >> 1 ) == slaveAddress) )
      {
        if ( USIDR & 0x01 )
        {
          USI_REQUEST_CALLBACK();
 2e6:	88 23       	and	r24, r24
 2e8:	19 f0       	breq	.+6      	; 0x2f0 <__stack+0x91>
usiTwiAmountDataInReceiveBuffer():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:459



uint8_t usiTwiAmountDataInReceiveBuffer(void)
{
    return rxCount;
 2ea:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <rxCount>
__vector_14():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:576
    case USI_SLAVE_CHECK_ADDRESS:
      if ( ( USIDR == 0 ) || ( ( USIDR >> 1 ) == slaveAddress) )
      {
        if ( USIDR & 0x01 )
        {
          USI_REQUEST_CALLBACK();
 2ee:	09 95       	icall
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:577
          overflowState = USI_SLAVE_SEND_DATA;
 2f0:	81 e0       	ldi	r24, 0x01	; 1
 2f2:	90 e0       	ldi	r25, 0x00	; 0
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:653
      } else {
        // overrun
        // drop data
      }
      // next USI_SLAVE_REQUEST_DATA
      overflowState = USI_SLAVE_REQUEST_DATA;
 2f4:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <overflowState+0x1>
 2f8:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <overflowState>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:654
      SET_USI_TO_SEND_ACK( );
 2fc:	1f b8       	out	0x0f, r1	; 15
 2fe:	b8 9a       	sbi	0x17, 0	; 23
 300:	2f c0       	rjmp	.+94     	; 0x360 <__stack+0x101>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:594
      break;

    // Master write data mode: check reply and goto USI_SLAVE_SEND_DATA if OK,
    // else reset USI
    case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
      if ( USIDR )
 302:	8f b1       	in	r24, 0x0f	; 15
 304:	88 23       	and	r24, r24
 306:	19 f0       	breq	.+6      	; 0x30e <__stack+0xaf>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:617
      }
      else
      {
        // the buffer is empty
        SET_USI_TO_READ_ACK( ); // This might be neccessary sometimes see http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&p=805227#805227
        SET_USI_TO_TWI_START_CONDITION_MODE( );
 308:	88 ea       	ldi	r24, 0xA8	; 168
 30a:	8d b9       	out	0x0d, r24	; 13
 30c:	19 c0       	rjmp	.+50     	; 0x340 <__stack+0xe1>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:607

    // copy data from buffer to USIDR and set USI to shift byte
    // next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
    case USI_SLAVE_SEND_DATA:
      // Get data from Buffer
      if ( txCount )
 30e:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <txCount>
 312:	88 23       	and	r24, r24
 314:	c1 f0       	breq	.+48     	; 0x346 <__stack+0xe7>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:609
      {
        USIDR = txBuf[ txTail ];
 316:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <txTail>
 31a:	1f b8       	out	0x0f, r1	; 15
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:610
        txTail = ( txTail + 1 ) & TWI_TX_BUFFER_MASK;
 31c:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <txTail>
 320:	8f 5f       	subi	r24, 0xFF	; 255
 322:	8f 70       	andi	r24, 0x0F	; 15
 324:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <txTail>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:611
        txCount--;
 328:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <txCount>
 32c:	81 50       	subi	r24, 0x01	; 1
 32e:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <txCount>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:620
        // the buffer is empty
        SET_USI_TO_READ_ACK( ); // This might be neccessary sometimes see http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&p=805227#805227
        SET_USI_TO_TWI_START_CONDITION_MODE( );
        return;
      } // end if
      overflowState = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 332:	82 e0       	ldi	r24, 0x02	; 2
 334:	90 e0       	ldi	r25, 0x00	; 0
 336:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <overflowState+0x1>
 33a:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <overflowState>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:621
      SET_USI_TO_SEND_DATA( );
 33e:	b8 9a       	sbi	0x17, 0	; 23
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:635

    // Master read data mode: set USI to sample data from master, next
    // USI_SLAVE_GET_DATA_AND_SEND_ACK
    case USI_SLAVE_REQUEST_DATA:
      overflowState = USI_SLAVE_GET_DATA_AND_SEND_ACK;
      SET_USI_TO_READ_DATA( );
 340:	80 e7       	ldi	r24, 0x70	; 112
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:654
        // overrun
        // drop data
      }
      // next USI_SLAVE_REQUEST_DATA
      overflowState = USI_SLAVE_REQUEST_DATA;
      SET_USI_TO_SEND_ACK( );
 342:	8e b9       	out	0x0e, r24	; 14
 344:	8c cf       	rjmp	.-232    	; 0x25e <__vector_14+0x3e>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:616
        txCount--;
      }
      else
      {
        // the buffer is empty
        SET_USI_TO_READ_ACK( ); // This might be neccessary sometimes see http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&p=805227#805227
 346:	b8 98       	cbi	0x17, 0	; 23
 348:	1f b8       	out	0x0f, r1	; 15
 34a:	8e e7       	ldi	r24, 0x7E	; 126
 34c:	8e b9       	out	0x0e, r24	; 14
 34e:	dc cf       	rjmp	.-72     	; 0x308 <__stack+0xa9>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:627
      break;

    // set USI to sample reply from master
    // next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
    case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
      overflowState = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 350:	83 e0       	ldi	r24, 0x03	; 3
 352:	90 e0       	ldi	r25, 0x00	; 0
 354:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <overflowState+0x1>
 358:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <overflowState>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:628
      SET_USI_TO_READ_ACK( );
 35c:	b8 98       	cbi	0x17, 0	; 23
 35e:	1f b8       	out	0x0f, r1	; 15
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:654
        // overrun
        // drop data
      }
      // next USI_SLAVE_REQUEST_DATA
      overflowState = USI_SLAVE_REQUEST_DATA;
      SET_USI_TO_SEND_ACK( );
 360:	8e e7       	ldi	r24, 0x7E	; 126
 362:	ef cf       	rjmp	.-34     	; 0x342 <__stack+0xe3>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:634
      break;

    // Master read data mode: set USI to sample data from master, next
    // USI_SLAVE_GET_DATA_AND_SEND_ACK
    case USI_SLAVE_REQUEST_DATA:
      overflowState = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 364:	85 e0       	ldi	r24, 0x05	; 5
 366:	90 e0       	ldi	r25, 0x00	; 0
 368:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <overflowState+0x1>
 36c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <overflowState>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:635
      SET_USI_TO_READ_DATA( );
 370:	b8 98       	cbi	0x17, 0	; 23
 372:	e6 cf       	rjmp	.-52     	; 0x340 <__stack+0xe1>

00000374 <__vector_13>:
__vector_13():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:472
                            USI Start Condition ISR

********************************************************************************/

ISR( USI_START_VECTOR )
{
 374:	1f 92       	push	r1
 376:	0f 92       	push	r0
 378:	0f b6       	in	r0, 0x3f	; 63
 37a:	0f 92       	push	r0
 37c:	11 24       	eor	r1, r1
 37e:	8f 93       	push	r24
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:484
  // This triggers on second write, but claims to the callback there is only *one* byte in buffer
  USI_RECEIVE_CALLBACK();
  */

  // set default starting conditions for new TWI package
  overflowState = USI_SLAVE_CHECK_ADDRESS;
 380:	10 92 71 00 	sts	0x0071, r1	; 0x800071 <overflowState+0x1>
 384:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <overflowState>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:487

  // set SDA as input
  DDR_USI &= ~( 1 << PORT_USI_SDA );
 388:	b8 98       	cbi	0x17, 0	; 23
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:494
  // wait for SCL to go low to ensure the Start Condition has completed (the
  // start detector will hold SCL low ) - if a Stop Condition arises then leave
  // the interrupt to prevent waiting forever - don't use USISR to test for Stop
  // Condition as in Application Note AVR312 because the Stop Condition Flag is
  // going to be set from the last TWI sequence
  while (
 38a:	b2 9b       	sbis	0x16, 2	; 22
 38c:	02 c0       	rjmp	.+4      	; 0x392 <__vector_13+0x1e>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:496
       // SCL his high
       ( PIN_USI & ( 1 << PIN_USI_SCL ) ) &&
 38e:	b0 9b       	sbis	0x16, 0	; 22
 390:	fc cf       	rjmp	.-8      	; 0x38a <__vector_13+0x16>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:502
       // and SDA is low
       !( ( PIN_USI & ( 1 << PIN_USI_SDA ) ) )
  );


  if ( !( PIN_USI & ( 1 << PIN_USI_SDA ) ) )
 392:	b0 99       	sbic	0x16, 0	; 22
 394:	0a c0       	rjmp	.+20     	; 0x3aa <__vector_13+0x36>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:507
  {

    // a Stop Condition did not occur

    USICR =
 396:	88 ef       	ldi	r24, 0xF8	; 248
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:525
  }
  else
  {
    // a Stop Condition did occur

    USICR =
 398:	8d b9       	out	0x0d, r24	; 13
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:540
         // no toggle clock-port pin
         ( 0 << USITC );

  } // end if

  USISR =
 39a:	80 ef       	ldi	r24, 0xF0	; 240
 39c:	8e b9       	out	0x0e, r24	; 14
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:549
       ( 1 << USIPF ) |( 1 << USIDC ) |
       // set USI to sample 8 bits (count 16 external SCL pin toggles)
       ( 0x0 << USICNT0);


} // end ISR( USI_START_VECTOR )
 39e:	8f 91       	pop	r24
 3a0:	0f 90       	pop	r0
 3a2:	0f be       	out	0x3f, r0	; 63
 3a4:	0f 90       	pop	r0
 3a6:	1f 90       	pop	r1
 3a8:	18 95       	reti
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:525
  }
  else
  {
    // a Stop Condition did occur

    USICR =
 3aa:	88 ea       	ldi	r24, 0xA8	; 168
 3ac:	f5 cf       	rjmp	.-22     	; 0x398 <__vector_13+0x24>

000003ae <main>:
main():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 3ae:	83 e0       	ldi	r24, 0x03	; 3
 3b0:	8a bd       	out	0x2a, r24	; 42
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 3b2:	83 bf       	out	0x33, r24	; 51
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 3b4:	78 94       	sei
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1167

  #ifndef DISABLEMILLIS
    // Enable the overflow interrupt (this is the basic system tic-toc for millis)
    #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
      sbi(TIMSK, TOIE0);
 3b6:	89 b7       	in	r24, 0x39	; 57
 3b8:	82 60       	ori	r24, 0x02	; 2
 3ba:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:958
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
      TCCR1B = 3; //prescaler of 64
    #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1) // ATtiny x5
      // Use the Tone Timer for fast PWM as phase correct not supported by this timer
      GTCCR = (1<<PWM1B);
 3bc:	80 e4       	ldi	r24, 0x40	; 64
 3be:	8c bd       	out	0x2c, r24	; 44
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:959
      OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 3c0:	8f ef       	ldi	r24, 0xFF	; 255
 3c2:	8d bd       	out	0x2d, r24	; 45
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:960
      TCCR1 = (1<<CTC1) | (1<<PWM1A) | (ToneTimer_Prescale_Index << CS10);
 3c4:	87 ec       	ldi	r24, 0xC7	; 199
 3c6:	80 bf       	out	0x30, r24	; 48
main():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 3c8:	86 e8       	ldi	r24, 0x86	; 134
 3ca:	86 b9       	out	0x06, r24	; 6
begin():
/home/bortex/arduino/antenna/antenna.ino:22
  RelaisController(uint8_t pinNumber)
      : pin(pinNumber), state(false) {}

  void begin()
  {
    pinMode(pin, OUTPUT);
 3cc:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <relais>
pinMode():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:34
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 3d0:	87 ff       	sbrs	r24, 7
 3d2:	0d c0       	rjmp	.+26     	; 0x3ee <main+0x40>
 3d4:	8f 77       	andi	r24, 0x7F	; 127
 3d6:	09 f4       	brne	.+2      	; 0x3da <main+0x2c>
 3d8:	5b c0       	rjmp	.+182    	; 0x490 <__LOCK_REGION_LENGTH__+0x90>
 3da:	81 30       	cpi	r24, 0x01	; 1
 3dc:	09 f4       	brne	.+2      	; 0x3e0 <main+0x32>
 3de:	5a c0       	rjmp	.+180    	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
 3e0:	82 30       	cpi	r24, 0x02	; 2
 3e2:	09 f4       	brne	.+2      	; 0x3e6 <main+0x38>
 3e4:	59 c0       	rjmp	.+178    	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
 3e6:	83 30       	cpi	r24, 0x03	; 3
 3e8:	09 f4       	brne	.+2      	; 0x3ec <main+0x3e>
 3ea:	58 c0       	rjmp	.+176    	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
main():
 3ec:	8f ef       	ldi	r24, 0xFF	; 255
pinMode():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:35
  uint8_t bit = digitalPinToBitMask(pin);
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	fc 01       	movw	r30, r24
 3f2:	e0 5d       	subi	r30, 0xD0	; 208
 3f4:	ff 4f       	sbci	r31, 0xFF	; 255
 3f6:	24 91       	lpm	r18, Z
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 3f8:	86 5d       	subi	r24, 0xD6	; 214
 3fa:	9f 4f       	sbci	r25, 0xFF	; 255
 3fc:	fc 01       	movw	r30, r24
 3fe:	84 91       	lpm	r24, Z
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 400:	88 23       	and	r24, r24
 402:	99 f0       	breq	.+38     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 404:	90 e0       	ldi	r25, 0x00	; 0
 406:	88 0f       	add	r24, r24
 408:	99 1f       	adc	r25, r25
 40a:	fc 01       	movw	r30, r24
 40c:	e2 5e       	subi	r30, 0xE2	; 226
 40e:	ff 4f       	sbci	r31, 0xFF	; 255
 410:	a5 91       	lpm	r26, Z+
 412:	b4 91       	lpm	r27, Z
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 414:	fc 01       	movw	r30, r24
 416:	ec 5d       	subi	r30, 0xDC	; 220
 418:	ff 4f       	sbci	r31, 0xFF	; 255
 41a:	85 91       	lpm	r24, Z+
 41c:	94 91       	lpm	r25, Z
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 41e:	8f b7       	in	r24, 0x3f	; 63
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:58
                cli();
 420:	f8 94       	cli
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:59
    *reg |= bit;
 422:	ec 91       	ld	r30, X
 424:	e2 2b       	or	r30, r18
 426:	ec 93       	st	X, r30
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:60
    SREG = oldSREG;
 428:	8f bf       	out	0x3f, r24	; 63
off():
/home/bortex/arduino/antenna/antenna.ino:32
    digitalWrite(pin, HIGH);
    state = true;
  }
  void off()
  {
    digitalWrite(pin, LOW);
 42a:	60 e0       	ldi	r22, 0x00	; 0
 42c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <relais>
 430:	21 de       	rcall	.-958    	; 0x74 <digitalWrite>
/home/bortex/arduino/antenna/antenna.ino:33
    state = false;
 432:	10 92 79 00 	sts	0x0079, r1	; 0x800079 <relais+0x1>
flushTwiBuffers():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:333
void
flushTwiBuffers(
  void
)
{
  rxTail = 0;
 436:	10 92 76 00 	sts	0x0076, r1	; 0x800076 <rxTail>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:334
  rxHead = 0;
 43a:	10 92 75 00 	sts	0x0075, r1	; 0x800075 <rxHead>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:335
  rxCount = 0;
 43e:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <rxCount>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:336
  txTail = 0;
 442:	10 92 74 00 	sts	0x0074, r1	; 0x800074 <txTail>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:337
  txHead = 0;
 446:	10 92 73 00 	sts	0x0073, r1	; 0x800073 <txHead>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:338
  txCount = 0;
 44a:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <txCount>
usiTwiSlaveInit():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:361
)
{

  flushTwiBuffers( );

  slaveAddress = ownAddress;
 44e:	82 e1       	ldi	r24, 0x12	; 18
 450:	80 93 77 00 	sts	0x0077, r24	; 0x800077 <slaveAddress>
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:369
  // low when a start condition is detected or a counter overflow (only
  // for USIWM1, USIWM0 = 11).  This inserts a wait state.  SCL is released
  // by the ISRs (USI_START_vect and USI_OVERFLOW_vect).

  // Set SCL and SDA as output
  DDR_USI |= ( 1 << PORT_USI_SCL ) | ( 1 << PORT_USI_SDA );
 454:	87 b3       	in	r24, 0x17	; 23
 456:	85 60       	ori	r24, 0x05	; 5
 458:	87 bb       	out	0x17, r24	; 23
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:372

  // set SCL high
  PORT_USI |= ( 1 << PORT_USI_SCL );
 45a:	c2 9a       	sbi	0x18, 2	; 24
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:375

  // set SDA high
  PORT_USI |= ( 1 << PORT_USI_SDA );
 45c:	c0 9a       	sbi	0x18, 0	; 24
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:378

  // Set SDA as input
  DDR_USI &= ~( 1 << PORT_USI_SDA );
 45e:	b8 98       	cbi	0x17, 0	; 23
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:380

  USICR =
 460:	88 ea       	ldi	r24, 0xA8	; 168
 462:	8d b9       	out	0x0d, r24	; 13
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:395
       // no toggle clock-port pin
       ( 0 << USITC );

  // clear all interrupt flags and reset overflow counter

  USISR = ( 1 << USI_START_COND_INT ) | ( 1 << USIOIF ) | ( 1 << USIPF ) | ( 1 << USIDC );
 464:	80 ef       	ldi	r24, 0xF0	; 240
 466:	8e b9       	out	0x0e, r24	; 14
onReceive():
/home/bortex/Arduino/libraries/TinyWireS/TinyWireS.cpp:53
}

// sets function called on slave write
void USI_TWI_S::onReceive( void (*function)(uint8_t) )
{
  usi_onReceiverPtr = function;
 468:	89 e8       	ldi	r24, 0x89	; 137
 46a:	90 e0       	ldi	r25, 0x00	; 0
 46c:	90 93 7c 00 	sts	0x007C, r25	; 0x80007c <usi_onReceiverPtr+0x1>
 470:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <usi_onReceiverPtr>
TinyWireS_stop_check():
/home/bortex/Arduino/libraries/TinyWireS/TinyWireS.cpp:64
  usi_onRequestPtr = function;
}

void TinyWireS_stop_check()
{
    if (!usi_onReceiverPtr)
 474:	e0 91 7b 00 	lds	r30, 0x007B	; 0x80007b <usi_onReceiverPtr>
 478:	f0 91 7c 00 	lds	r31, 0x007C	; 0x80007c <usi_onReceiverPtr+0x1>
 47c:	30 97       	sbiw	r30, 0x00	; 0
 47e:	f1 f3       	breq	.-4      	; 0x47c <__LOCK_REGION_LENGTH__+0x7c>
/home/bortex/Arduino/libraries/TinyWireS/TinyWireS.cpp:69
    {
        // no onReceive callback, nothing to do...
        return;
    }
    if (!(USISR & ( 1 << USIPF )))
 480:	75 9b       	sbis	0x0e, 5	; 14
 482:	f8 cf       	rjmp	.-16     	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
usiTwiAmountDataInReceiveBuffer():
/home/bortex/Arduino/libraries/TinyWireS/usiTwiSlave.c:459



uint8_t usiTwiAmountDataInReceiveBuffer(void)
{
    return rxCount;
 484:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <rxCount>
TinyWireS_stop_check():
/home/bortex/Arduino/libraries/TinyWireS/TinyWireS.cpp:75
    {
        // Stop not detected
        return;
    }
    uint8_t amount = usiTwiAmountDataInReceiveBuffer();
    if (amount == 0)
 488:	88 23       	and	r24, r24
 48a:	a1 f3       	breq	.-24     	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
/home/bortex/Arduino/libraries/TinyWireS/TinyWireS.cpp:80
    {
        // no data in buffer
        return;
    }
    usi_onReceiverPtr(amount);
 48c:	09 95       	icall
 48e:	f2 cf       	rjmp	.-28     	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
main():
/home/bortex/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:34
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 490:	85 e0       	ldi	r24, 0x05	; 5
 492:	ad cf       	rjmp	.-166    	; 0x3ee <main+0x40>
 494:	82 e0       	ldi	r24, 0x02	; 2
 496:	ab cf       	rjmp	.-170    	; 0x3ee <main+0x40>
 498:	84 e0       	ldi	r24, 0x04	; 4
 49a:	a9 cf       	rjmp	.-174    	; 0x3ee <main+0x40>
 49c:	83 e0       	ldi	r24, 0x03	; 3
 49e:	a7 cf       	rjmp	.-178    	; 0x3ee <main+0x40>

000004a0 <_GLOBAL__sub_I_relais>:
_ZN16RelaisControllerC2Eh():
/home/bortex/arduino/antenna/antenna.ino:18
  uint8_t pin;
  bool state;

public:
  RelaisController(uint8_t pinNumber)
      : pin(pinNumber), state(false) {}
 4a0:	e8 e7       	ldi	r30, 0x78	; 120
 4a2:	f0 e0       	ldi	r31, 0x00	; 0
 4a4:	81 e0       	ldi	r24, 0x01	; 1
 4a6:	80 83       	st	Z, r24
 4a8:	11 82       	std	Z+1, r1	; 0x01
_GLOBAL__sub_I_relais():
/home/bortex/arduino/antenna/antenna.ino:87

void loop()
{
  // must be called frequently to detect STOP and invoke onReceive
  TinyWireS_stop_check();
}
 4aa:	08 95       	ret

000004ac <__tablejump2__>:
__tablejump2__():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 4ac:	ee 0f       	add	r30, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 4ae:	ff 1f       	adc	r31, r31
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 4b0:	05 90       	lpm	r0, Z+
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 4b2:	f4 91       	lpm	r31, Z
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 4b4:	e0 2d       	mov	r30, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 4b6:	09 94       	ijmp

000004b8 <_exit>:
exit():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 4b8:	f8 94       	cli

000004ba <__stop_program>:
__stop_program():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 4ba:	ff cf       	rjmp	.-2      	; 0x4ba <__stop_program>
